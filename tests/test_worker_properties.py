"""
Property-Based Tests for Worker Lambda Event Format.

This module contains property-based tests using Hypothesis to verify
the correctness properties of the Worker event format generated by
the scheduler_handler.invoke_workers_async function.

**Validates: Requirements 6.2, 6.5, 7.2**
"""

import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

import pytest
from hypothesis import given, strategies as st, settings, assume

from worker_handler import validate_event, EventValidationError


def generate_worker_event(
    accounts: List[Dict[str, str]],
    group_index: int,
    total_groups: int,
    invocation_id: str,
    timestamp: str
) -> Dict[str, Any]:
    """
    Generate a Worker event payload in the same format as invoke_workers_async.
    
    This function replicates the event generation logic from scheduler_handler
    to enable property-based testing of the event format.
    
    Args:
        accounts: List of account dictionaries
        group_index: Index of this account group
        total_groups: Total number of groups
        invocation_id: Unique ID for this scheduling run
        timestamp: ISO format timestamp of invocation
        
    Returns:
        Dict containing the Worker event payload
    """
    return {
        'accounts': accounts,
        'group_index': group_index,
        'total_groups': total_groups,
        'invocation_id': invocation_id,
        'timestamp': timestamp
    }


class TestWorkerEventFormatProperties:
    """Property-based tests for Worker event format correctness."""
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        accounts=st.lists(
            st.fixed_dictionaries({
                'Id': st.text(min_size=12, max_size=12, alphabet='0123456789'),
                'Name': st.text(min_size=1, max_size=50),
                'Email': st.emails()
            }),
            min_size=0,
            max_size=100
        ),
        group_index=st.integers(min_value=0, max_value=100),
        total_groups=st.integers(min_value=1, max_value=100)
    )
    def test_worker_event_format_correctness(self, accounts, group_index, total_groups):
        """
        Feature: cloudformation-deployment, Property 2: Worker事件格式正确性
        
        **Validates: Requirements 6.2**
        
        For any account group, the generated Worker invocation event should:
        1. Contain all required fields (accounts, group_index, total_groups, 
           invocation_id, timestamp)
        2. Each account in the accounts field should contain Id, Name, Email fields
        
        对于任何账号分组，生成的Worker调用事件应包含所有必需字段
        （accounts、group_index、total_groups、invocation_id、timestamp），
        且accounts字段中的每个账号都包含Id、Name、Email字段。
        """
        # Generate event using the same logic as invoke_workers_async
        invocation_id = str(uuid.uuid4())
        timestamp = datetime.now(timezone.utc).isoformat()
        
        event = generate_worker_event(
            accounts=accounts,
            group_index=group_index,
            total_groups=total_groups,
            invocation_id=invocation_id,
            timestamp=timestamp
        )
        
        # Property 1: Event contains all required top-level fields
        required_fields = ['accounts', 'group_index', 'total_groups', 'invocation_id', 'timestamp']
        for field in required_fields:
            assert field in event, (
                f"Event missing required field: '{field}'. "
                f"Event keys: {list(event.keys())}"
            )
        
        # Property 2: Field types are correct
        assert isinstance(event['accounts'], list), (
            f"'accounts' must be a list, got {type(event['accounts']).__name__}"
        )
        assert isinstance(event['group_index'], int), (
            f"'group_index' must be an int, got {type(event['group_index']).__name__}"
        )
        assert isinstance(event['total_groups'], int), (
            f"'total_groups' must be an int, got {type(event['total_groups']).__name__}"
        )
        assert isinstance(event['invocation_id'], str), (
            f"'invocation_id' must be a string, got {type(event['invocation_id']).__name__}"
        )
        assert isinstance(event['timestamp'], str), (
            f"'timestamp' must be a string, got {type(event['timestamp']).__name__}"
        )
        
        # Property 3: invocation_id is a valid UUID string
        try:
            uuid.UUID(event['invocation_id'])
        except ValueError:
            pytest.fail(
                f"'invocation_id' is not a valid UUID: {event['invocation_id']}"
            )
        
        # Property 4: timestamp is a valid ISO format string
        assert len(event['timestamp']) > 0, "'timestamp' must not be empty"
        
        # Property 5: group_index is non-negative
        assert event['group_index'] >= 0, (
            f"'group_index' must be non-negative, got {event['group_index']}"
        )
        
        # Property 6: total_groups is positive
        assert event['total_groups'] >= 1, (
            f"'total_groups' must be at least 1, got {event['total_groups']}"
        )
        
        # Property 7: Each account contains required fields (Id, Name, Email)
        account_required_fields = ['Id', 'Name', 'Email']
        for i, account in enumerate(event['accounts']):
            assert isinstance(account, dict), (
                f"Account at index {i} must be a dictionary, "
                f"got {type(account).__name__}"
            )
            
            for field in account_required_fields:
                assert field in account, (
                    f"Account at index {i} missing required field: '{field}'. "
                    f"Account keys: {list(account.keys())}"
                )
            
            # Validate field types for each account
            assert isinstance(account['Id'], str), (
                f"Account at index {i} 'Id' must be a string, "
                f"got {type(account['Id']).__name__}"
            )
            assert isinstance(account['Name'], str), (
                f"Account at index {i} 'Name' must be a string, "
                f"got {type(account['Name']).__name__}"
            )
            assert isinstance(account['Email'], str), (
                f"Account at index {i} 'Email' must be a string, "
                f"got {type(account['Email']).__name__}"
            )
        
        # Property 8: accounts list length matches input
        assert len(event['accounts']) == len(accounts), (
            f"Event accounts count ({len(event['accounts'])}) does not match "
            f"input accounts count ({len(accounts)})"
        )


def generate_worker_response(
    status_code: int,
    group_index: int,
    accounts_processed: int,
    accounts_failed: int,
    alerts_generated: int,
    execution_time_seconds: float,
    errors: List[str]
) -> Dict[str, Any]:
    """
    Generate a Worker response payload in the same format as worker_handler.lambda_handler.
    
    This function replicates the response generation logic from worker_handler
    to enable property-based testing of the response format.
    
    Args:
        status_code: HTTP status code (200 for success, 400/500 for errors)
        group_index: Index of this account group
        accounts_processed: Number of accounts successfully processed
        accounts_failed: Number of accounts that failed processing
        alerts_generated: Total number of alerts sent
        execution_time_seconds: Total execution time
        errors: List of any errors encountered
        
    Returns:
        Dict containing the Worker response payload
    """
    return {
        'statusCode': status_code,
        'group_index': group_index,
        'accounts_processed': accounts_processed,
        'accounts_failed': accounts_failed,
        'alerts_generated': alerts_generated,
        'execution_time_seconds': execution_time_seconds,
        'errors': errors
    }


class TestWorkerReturnFormatProperties:
    """Property-based tests for Worker return format correctness."""
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        status_code=st.sampled_from([200, 400, 500]),
        group_index=st.integers(min_value=0, max_value=100),
        accounts_processed=st.integers(min_value=0, max_value=500),
        accounts_failed=st.integers(min_value=0, max_value=500),
        alerts_generated=st.integers(min_value=0, max_value=1000),
        execution_time_seconds=st.floats(min_value=0.0, max_value=900.0, allow_nan=False, allow_infinity=False),
        errors=st.lists(st.text(min_size=0, max_size=200), min_size=0, max_size=10)
    )
    def test_worker_return_format_correctness(
        self,
        status_code,
        group_index,
        accounts_processed,
        accounts_failed,
        alerts_generated,
        execution_time_seconds,
        errors
    ):
        """
        Feature: cloudformation-deployment, Property 3: Worker返回格式正确性
        
        **Validates: Requirements 7.2**
        
        For any Worker processing result, the returned response should:
        1. Contain all required fields (statusCode, group_index, accounts_processed,
           accounts_failed, alerts_generated, execution_time_seconds)
        2. All numeric fields should be non-negative
        
        对于任何Worker处理结果，返回的响应应包含所有必需字段
        （statusCode、group_index、accounts_processed、accounts_failed、
        alerts_generated、execution_time_seconds），且数值字段为非负数。
        """
        # Generate response using the same logic as worker_handler.lambda_handler
        response = generate_worker_response(
            status_code=status_code,
            group_index=group_index,
            accounts_processed=accounts_processed,
            accounts_failed=accounts_failed,
            alerts_generated=alerts_generated,
            execution_time_seconds=execution_time_seconds,
            errors=errors
        )
        
        # Property 1: Response contains all required fields
        required_fields = [
            'statusCode',
            'group_index',
            'accounts_processed',
            'accounts_failed',
            'alerts_generated',
            'execution_time_seconds'
        ]
        for field in required_fields:
            assert field in response, (
                f"Response missing required field: '{field}'. "
                f"Response keys: {list(response.keys())}"
            )
        
        # Property 2: Field types are correct
        assert isinstance(response['statusCode'], int), (
            f"'statusCode' must be an int, got {type(response['statusCode']).__name__}"
        )
        assert isinstance(response['group_index'], int), (
            f"'group_index' must be an int, got {type(response['group_index']).__name__}"
        )
        assert isinstance(response['accounts_processed'], int), (
            f"'accounts_processed' must be an int, got {type(response['accounts_processed']).__name__}"
        )
        assert isinstance(response['accounts_failed'], int), (
            f"'accounts_failed' must be an int, got {type(response['accounts_failed']).__name__}"
        )
        assert isinstance(response['alerts_generated'], int), (
            f"'alerts_generated' must be an int, got {type(response['alerts_generated']).__name__}"
        )
        assert isinstance(response['execution_time_seconds'], (int, float)), (
            f"'execution_time_seconds' must be a number, got {type(response['execution_time_seconds']).__name__}"
        )
        
        # Property 3: statusCode is a valid HTTP status code
        assert response['statusCode'] in [200, 400, 500], (
            f"'statusCode' must be 200, 400, or 500, got {response['statusCode']}"
        )
        
        # Property 4: group_index is non-negative
        assert response['group_index'] >= 0, (
            f"'group_index' must be non-negative, got {response['group_index']}"
        )
        
        # Property 5: accounts_processed is non-negative
        assert response['accounts_processed'] >= 0, (
            f"'accounts_processed' must be non-negative, got {response['accounts_processed']}"
        )
        
        # Property 6: accounts_failed is non-negative
        assert response['accounts_failed'] >= 0, (
            f"'accounts_failed' must be non-negative, got {response['accounts_failed']}"
        )
        
        # Property 7: alerts_generated is non-negative
        assert response['alerts_generated'] >= 0, (
            f"'alerts_generated' must be non-negative, got {response['alerts_generated']}"
        )
        
        # Property 8: execution_time_seconds is non-negative
        assert response['execution_time_seconds'] >= 0, (
            f"'execution_time_seconds' must be non-negative, got {response['execution_time_seconds']}"
        )
        
        # Property 9: errors field exists and is a list (optional but expected)
        if 'errors' in response:
            assert isinstance(response['errors'], list), (
                f"'errors' must be a list, got {type(response['errors']).__name__}"
            )


class TestInputValidationProperties:
    """
    Property-based tests for input validation correctness.
    
    Feature: cloudformation-deployment, Property 4: 输入验证正确性
    
    **Validates: Requirements 6.5**
    
    For any event passed to Worker, if the event format is incorrect
    (missing 'accounts' field, 'accounts' is not a list, account missing
    required fields), Worker should return a validation error instead of crashing.
    
    对于任何传入Worker的事件，如果事件格式不正确（缺少accounts字段、
    accounts不是列表、账号缺少必需字段），Worker应返回验证错误而不是崩溃。
    """
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        event=st.fixed_dictionaries({
            'group_index': st.integers(min_value=0, max_value=100),
            'total_groups': st.integers(min_value=1, max_value=100),
            'invocation_id': st.text(min_size=1, max_size=50),
            'timestamp': st.text(min_size=1, max_size=50)
        })
    )
    def test_event_missing_accounts_field_raises_error(self, event):
        """
        Test Case 1: Event missing 'accounts' field should raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any event that does not contain the 'accounts' field,
        validate_event should raise EventValidationError.
        """
        # Ensure 'accounts' is not in the event
        assert 'accounts' not in event
        
        # validate_event should raise EventValidationError, not crash
        with pytest.raises(EventValidationError) as exc_info:
            validate_event(event)
        
        # Verify the error message mentions the missing field
        assert 'accounts' in str(exc_info.value).lower()
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        invalid_accounts=st.one_of(
            st.none(),
            st.integers(),
            st.floats(allow_nan=False, allow_infinity=False),
            st.text(),
            st.booleans(),
            st.fixed_dictionaries({
                'key': st.text(min_size=1, max_size=20)
            })
        )
    )
    def test_accounts_not_a_list_raises_error(self, invalid_accounts):
        """
        Test Case 2: 'accounts' is not a list should raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any event where 'accounts' is not a list (e.g., None, int, str, dict),
        validate_event should raise EventValidationError.
        """
        event = {
            'accounts': invalid_accounts,
            'group_index': 0,
            'total_groups': 1,
            'invocation_id': 'test-id',
            'timestamp': '2024-01-01T00:00:00Z'
        }
        
        # validate_event should raise EventValidationError, not crash
        with pytest.raises(EventValidationError) as exc_info:
            validate_event(event)
        
        # Verify the error message mentions 'accounts' and 'list'
        error_msg = str(exc_info.value).lower()
        assert 'accounts' in error_msg or 'list' in error_msg
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        missing_field=st.sampled_from(['Id', 'Name', 'Email']),
        account_id=st.text(min_size=12, max_size=12, alphabet='0123456789'),
        account_name=st.text(min_size=1, max_size=50),
        account_email=st.emails()
    )
    def test_account_missing_required_fields_raises_error(
        self, missing_field, account_id, account_name, account_email
    ):
        """
        Test Case 3: Account missing required fields (Id, Name, Email) should raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any account in the accounts list that is missing one of the required
        fields (Id, Name, Email), validate_event should raise EventValidationError.
        """
        # Create a complete account and then remove one field
        account = {
            'Id': account_id,
            'Name': account_name,
            'Email': account_email
        }
        del account[missing_field]
        
        event = {
            'accounts': [account],
            'group_index': 0,
            'total_groups': 1,
            'invocation_id': 'test-id',
            'timestamp': '2024-01-01T00:00:00Z'
        }
        
        # validate_event should raise EventValidationError, not crash
        with pytest.raises(EventValidationError) as exc_info:
            validate_event(event)
        
        # Verify the error message mentions the missing field
        error_msg = str(exc_info.value)
        assert missing_field in error_msg or 'missing' in error_msg.lower()
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        wrong_type_field=st.sampled_from(['Id', 'Name', 'Email']),
        wrong_type_value=st.one_of(
            st.integers(),
            st.floats(allow_nan=False, allow_infinity=False),
            st.booleans(),
            st.lists(st.text(min_size=1, max_size=10), min_size=0, max_size=3),
            st.none()
        ),
        account_id=st.text(min_size=12, max_size=12, alphabet='0123456789'),
        account_name=st.text(min_size=1, max_size=50),
        account_email=st.emails()
    )
    def test_account_fields_wrong_types_raises_error(
        self, wrong_type_field, wrong_type_value, account_id, account_name, account_email
    ):
        """
        Test Case 4: Account fields have wrong types should raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any account where a required field (Id, Name, Email) has the wrong type
        (not a string), validate_event should raise EventValidationError.
        """
        # Create a complete account with correct types
        account = {
            'Id': account_id,
            'Name': account_name,
            'Email': account_email
        }
        
        # Replace one field with a wrong type value
        account[wrong_type_field] = wrong_type_value
        
        event = {
            'accounts': [account],
            'group_index': 0,
            'total_groups': 1,
            'invocation_id': 'test-id',
            'timestamp': '2024-01-01T00:00:00Z'
        }
        
        # validate_event should raise EventValidationError, not crash
        with pytest.raises(EventValidationError) as exc_info:
            validate_event(event)
        
        # Verify the error message mentions the field or type issue
        error_msg = str(exc_info.value).lower()
        assert (
            wrong_type_field.lower() in error_msg or 
            'invalid' in error_msg or 
            'string' in error_msg or
            'must be' in error_msg
        )
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        invalid_account=st.one_of(
            st.none(),
            st.integers(),
            st.floats(allow_nan=False, allow_infinity=False),
            st.text(),
            st.booleans(),
            st.lists(st.text(min_size=1, max_size=10), min_size=0, max_size=3)
        )
    )
    def test_account_not_a_dict_raises_error(self, invalid_account):
        """
        Test Case 5: Account in list is not a dictionary should raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any account in the accounts list that is not a dictionary,
        validate_event should raise EventValidationError.
        """
        event = {
            'accounts': [invalid_account],
            'group_index': 0,
            'total_groups': 1,
            'invocation_id': 'test-id',
            'timestamp': '2024-01-01T00:00:00Z'
        }
        
        # validate_event should raise EventValidationError, not crash
        with pytest.raises(EventValidationError) as exc_info:
            validate_event(event)
        
        # Verify the error message mentions dictionary or type issue
        error_msg = str(exc_info.value).lower()
        assert 'dictionary' in error_msg or 'dict' in error_msg or 'account' in error_msg
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        valid_accounts=st.lists(
            st.fixed_dictionaries({
                'Id': st.text(min_size=12, max_size=12, alphabet='0123456789'),
                'Name': st.text(min_size=1, max_size=50),
                'Email': st.emails()
            }),
            min_size=0,
            max_size=50
        )
    )
    def test_valid_event_does_not_raise_error(self, valid_accounts):
        """
        Test Case 6: Valid event should not raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any valid event with properly formatted accounts,
        validate_event should return the accounts list without raising an error.
        """
        event = {
            'accounts': valid_accounts,
            'group_index': 0,
            'total_groups': 1,
            'invocation_id': 'test-id',
            'timestamp': '2024-01-01T00:00:00Z'
        }
        
        # validate_event should not raise any exception
        result = validate_event(event)
        
        # Result should be a list with the same length as input
        assert isinstance(result, list)
        assert len(result) == len(valid_accounts)
        
        # Each account in result should have required fields
        for account in result:
            assert 'Id' in account
            assert 'Name' in account
            assert 'Email' in account
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        event_type=st.one_of(
            st.none(),
            st.integers(),
            st.floats(allow_nan=False, allow_infinity=False),
            st.text(),
            st.booleans(),
            st.lists(st.text(min_size=1, max_size=10), min_size=0, max_size=3)
        )
    )
    def test_event_not_a_dict_raises_error(self, event_type):
        """
        Test Case 7: Event is not a dictionary should raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any event that is not a dictionary,
        validate_event should raise EventValidationError.
        """
        # validate_event should raise EventValidationError, not crash
        with pytest.raises(EventValidationError) as exc_info:
            validate_event(event_type)
        
        # Verify the error message mentions dictionary
        error_msg = str(exc_info.value).lower()
        assert 'dictionary' in error_msg or 'dict' in error_msg
    
    @pytest.mark.property
    @settings(max_examples=100)
    @given(
        account_id=st.text(min_size=12, max_size=12, alphabet='0123456789'),
        account_name=st.text(min_size=1, max_size=50),
        account_email=st.emails()
    )
    def test_empty_id_raises_error(self, account_id, account_name, account_email):
        """
        Test Case 8: Account with empty Id should raise EventValidationError.
        
        **Validates: Requirements 6.5**
        
        For any account where Id is an empty string,
        validate_event should raise EventValidationError.
        """
        account = {
            'Id': '',  # Empty string
            'Name': account_name,
            'Email': account_email
        }
        
        event = {
            'accounts': [account],
            'group_index': 0,
            'total_groups': 1,
            'invocation_id': 'test-id',
            'timestamp': '2024-01-01T00:00:00Z'
        }
        
        # validate_event should raise EventValidationError, not crash
        with pytest.raises(EventValidationError) as exc_info:
            validate_event(event)
        
        # Verify the error message mentions Id or empty
        error_msg = str(exc_info.value).lower()
        assert 'id' in error_msg or 'empty' in error_msg or 'non-empty' in error_msg
